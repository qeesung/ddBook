// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modeTable.proto

#ifndef PROTOBUF_modeTable_2eproto__INCLUDED
#define PROTOBUF_modeTable_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace modeTable {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_modeTable_2eproto();
void protobuf_AssignDesc_modeTable_2eproto();
void protobuf_ShutdownFile_modeTable_2eproto();

class Node;
class Node_GivenAudioPair;
class Link;
class MTFile;

// ===================================================================

class Node_GivenAudioPair : public ::google::protobuf::Message {
 public:
  Node_GivenAudioPair();
  virtual ~Node_GivenAudioPair();

  Node_GivenAudioPair(const Node_GivenAudioPair& from);

  inline Node_GivenAudioPair& operator=(const Node_GivenAudioPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node_GivenAudioPair& default_instance();

  void Swap(Node_GivenAudioPair* other);

  // implements Message ----------------------------------------------

  inline Node_GivenAudioPair* New() const { return New(NULL); }

  Node_GivenAudioPair* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node_GivenAudioPair& from);
  void MergeFrom(const Node_GivenAudioPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Node_GivenAudioPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string givenCode = 1;
  inline bool has_givencode() const;
  inline void clear_givencode();
  static const int kGivenCodeFieldNumber = 1;
  inline const ::std::string& givencode() const;
  inline void set_givencode(const ::std::string& value);
  inline void set_givencode(const char* value);
  inline void set_givencode(const char* value, size_t size);
  inline ::std::string* mutable_givencode();
  inline ::std::string* release_givencode();
  inline void set_allocated_givencode(::std::string* givencode);

  // required string givenAudio = 2;
  inline bool has_givenaudio() const;
  inline void clear_givenaudio();
  static const int kGivenAudioFieldNumber = 2;
  inline const ::std::string& givenaudio() const;
  inline void set_givenaudio(const ::std::string& value);
  inline void set_givenaudio(const char* value);
  inline void set_givenaudio(const char* value, size_t size);
  inline ::std::string* mutable_givenaudio();
  inline ::std::string* release_givenaudio();
  inline void set_allocated_givenaudio(::std::string* givenaudio);

  // @@protoc_insertion_point(class_scope:modeTable.Node.GivenAudioPair)
 private:
  inline void set_has_givencode();
  inline void clear_has_givencode();
  inline void set_has_givenaudio();
  inline void clear_has_givenaudio();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr givencode_;
  ::google::protobuf::internal::ArenaStringPtr givenaudio_;
  friend void  protobuf_AddDesc_modeTable_2eproto();
  friend void protobuf_AssignDesc_modeTable_2eproto();
  friend void protobuf_ShutdownFile_modeTable_2eproto();

  void InitAsDefaultInstance();
  static Node_GivenAudioPair* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  inline Node* New() const { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Node_GivenAudioPair GivenAudioPair;

  // accessors -------------------------------------------------------

  // required double xPos = 1;
  inline bool has_xpos() const;
  inline void clear_xpos();
  static const int kXPosFieldNumber = 1;
  inline double xpos() const;
  inline void set_xpos(double value);

  // required double yPos = 2;
  inline bool has_ypos() const;
  inline void clear_ypos();
  static const int kYPosFieldNumber = 2;
  inline double ypos() const;
  inline void set_ypos(double value);

  // required string nodeName = 3;
  inline bool has_nodename() const;
  inline void clear_nodename();
  static const int kNodeNameFieldNumber = 3;
  inline const ::std::string& nodename() const;
  inline void set_nodename(const ::std::string& value);
  inline void set_nodename(const char* value);
  inline void set_nodename(const char* value, size_t size);
  inline ::std::string* mutable_nodename();
  inline ::std::string* release_nodename();
  inline void set_allocated_nodename(::std::string* nodename);

  // required string textColor = 4;
  inline bool has_textcolor() const;
  inline void clear_textcolor();
  static const int kTextColorFieldNumber = 4;
  inline const ::std::string& textcolor() const;
  inline void set_textcolor(const ::std::string& value);
  inline void set_textcolor(const char* value);
  inline void set_textcolor(const char* value, size_t size);
  inline ::std::string* mutable_textcolor();
  inline ::std::string* release_textcolor();
  inline void set_allocated_textcolor(::std::string* textcolor);

  // required string outlineColor = 5;
  inline bool has_outlinecolor() const;
  inline void clear_outlinecolor();
  static const int kOutlineColorFieldNumber = 5;
  inline const ::std::string& outlinecolor() const;
  inline void set_outlinecolor(const ::std::string& value);
  inline void set_outlinecolor(const char* value);
  inline void set_outlinecolor(const char* value, size_t size);
  inline ::std::string* mutable_outlinecolor();
  inline ::std::string* release_outlinecolor();
  inline void set_allocated_outlinecolor(::std::string* outlinecolor);

  // required string backgroundColor = 6;
  inline bool has_backgroundcolor() const;
  inline void clear_backgroundcolor();
  static const int kBackgroundColorFieldNumber = 6;
  inline const ::std::string& backgroundcolor() const;
  inline void set_backgroundcolor(const ::std::string& value);
  inline void set_backgroundcolor(const char* value);
  inline void set_backgroundcolor(const char* value, size_t size);
  inline ::std::string* mutable_backgroundcolor();
  inline ::std::string* release_backgroundcolor();
  inline void set_allocated_backgroundcolor(::std::string* backgroundcolor);

  // required string transCodeTextColor = 7;
  inline bool has_transcodetextcolor() const;
  inline void clear_transcodetextcolor();
  static const int kTransCodeTextColorFieldNumber = 7;
  inline const ::std::string& transcodetextcolor() const;
  inline void set_transcodetextcolor(const ::std::string& value);
  inline void set_transcodetextcolor(const char* value);
  inline void set_transcodetextcolor(const char* value, size_t size);
  inline ::std::string* mutable_transcodetextcolor();
  inline ::std::string* release_transcodetextcolor();
  inline void set_allocated_transcodetextcolor(::std::string* transcodetextcolor);

  // required string transCodeBackgroundColor = 8;
  inline bool has_transcodebackgroundcolor() const;
  inline void clear_transcodebackgroundcolor();
  static const int kTransCodeBackgroundColorFieldNumber = 8;
  inline const ::std::string& transcodebackgroundcolor() const;
  inline void set_transcodebackgroundcolor(const ::std::string& value);
  inline void set_transcodebackgroundcolor(const char* value);
  inline void set_transcodebackgroundcolor(const char* value, size_t size);
  inline ::std::string* mutable_transcodebackgroundcolor();
  inline ::std::string* release_transcodebackgroundcolor();
  inline void set_allocated_transcodebackgroundcolor(::std::string* transcodebackgroundcolor);

  // optional string startAudio = 9;
  inline bool has_startaudio() const;
  inline void clear_startaudio();
  static const int kStartAudioFieldNumber = 9;
  inline const ::std::string& startaudio() const;
  inline void set_startaudio(const ::std::string& value);
  inline void set_startaudio(const char* value);
  inline void set_startaudio(const char* value, size_t size);
  inline ::std::string* mutable_startaudio();
  inline ::std::string* release_startaudio();
  inline void set_allocated_startaudio(::std::string* startaudio);

  // optional string endAudio = 10;
  inline bool has_endaudio() const;
  inline void clear_endaudio();
  static const int kEndAudioFieldNumber = 10;
  inline const ::std::string& endaudio() const;
  inline void set_endaudio(const ::std::string& value);
  inline void set_endaudio(const char* value);
  inline void set_endaudio(const char* value, size_t size);
  inline ::std::string* mutable_endaudio();
  inline ::std::string* release_endaudio();
  inline void set_allocated_endaudio(::std::string* endaudio);

  // optional string transCode = 11;
  inline bool has_transcode() const;
  inline void clear_transcode();
  static const int kTransCodeFieldNumber = 11;
  inline const ::std::string& transcode() const;
  inline void set_transcode(const ::std::string& value);
  inline void set_transcode(const char* value);
  inline void set_transcode(const char* value, size_t size);
  inline ::std::string* mutable_transcode();
  inline ::std::string* release_transcode();
  inline void set_allocated_transcode(::std::string* transcode);

  // optional string pictureFile = 12;
  inline bool has_picturefile() const;
  inline void clear_picturefile();
  static const int kPictureFileFieldNumber = 12;
  inline const ::std::string& picturefile() const;
  inline void set_picturefile(const ::std::string& value);
  inline void set_picturefile(const char* value);
  inline void set_picturefile(const char* value, size_t size);
  inline ::std::string* mutable_picturefile();
  inline ::std::string* release_picturefile();
  inline void set_allocated_picturefile(::std::string* picturefile);

  // repeated .modeTable.Node.GivenAudioPair givenAudios = 13;
  inline int givenaudios_size() const;
  inline void clear_givenaudios();
  static const int kGivenAudiosFieldNumber = 13;
  inline const ::modeTable::Node_GivenAudioPair& givenaudios(int index) const;
  inline ::modeTable::Node_GivenAudioPair* mutable_givenaudios(int index);
  inline ::modeTable::Node_GivenAudioPair* add_givenaudios();
  inline const ::google::protobuf::RepeatedPtrField< ::modeTable::Node_GivenAudioPair >&
      givenaudios() const;
  inline ::google::protobuf::RepeatedPtrField< ::modeTable::Node_GivenAudioPair >*
      mutable_givenaudios();

  // required string nodeID = 14;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIDFieldNumber = 14;
  inline const ::std::string& nodeid() const;
  inline void set_nodeid(const ::std::string& value);
  inline void set_nodeid(const char* value);
  inline void set_nodeid(const char* value, size_t size);
  inline ::std::string* mutable_nodeid();
  inline ::std::string* release_nodeid();
  inline void set_allocated_nodeid(::std::string* nodeid);

  // @@protoc_insertion_point(class_scope:modeTable.Node)
 private:
  inline void set_has_xpos();
  inline void clear_has_xpos();
  inline void set_has_ypos();
  inline void clear_has_ypos();
  inline void set_has_nodename();
  inline void clear_has_nodename();
  inline void set_has_textcolor();
  inline void clear_has_textcolor();
  inline void set_has_outlinecolor();
  inline void clear_has_outlinecolor();
  inline void set_has_backgroundcolor();
  inline void clear_has_backgroundcolor();
  inline void set_has_transcodetextcolor();
  inline void clear_has_transcodetextcolor();
  inline void set_has_transcodebackgroundcolor();
  inline void clear_has_transcodebackgroundcolor();
  inline void set_has_startaudio();
  inline void clear_has_startaudio();
  inline void set_has_endaudio();
  inline void clear_has_endaudio();
  inline void set_has_transcode();
  inline void clear_has_transcode();
  inline void set_has_picturefile();
  inline void clear_has_picturefile();
  inline void set_has_nodeid();
  inline void clear_has_nodeid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double xpos_;
  double ypos_;
  ::google::protobuf::internal::ArenaStringPtr nodename_;
  ::google::protobuf::internal::ArenaStringPtr textcolor_;
  ::google::protobuf::internal::ArenaStringPtr outlinecolor_;
  ::google::protobuf::internal::ArenaStringPtr backgroundcolor_;
  ::google::protobuf::internal::ArenaStringPtr transcodetextcolor_;
  ::google::protobuf::internal::ArenaStringPtr transcodebackgroundcolor_;
  ::google::protobuf::internal::ArenaStringPtr startaudio_;
  ::google::protobuf::internal::ArenaStringPtr endaudio_;
  ::google::protobuf::internal::ArenaStringPtr transcode_;
  ::google::protobuf::internal::ArenaStringPtr picturefile_;
  ::google::protobuf::RepeatedPtrField< ::modeTable::Node_GivenAudioPair > givenaudios_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  friend void  protobuf_AddDesc_modeTable_2eproto();
  friend void protobuf_AssignDesc_modeTable_2eproto();
  friend void protobuf_ShutdownFile_modeTable_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class Link : public ::google::protobuf::Message {
 public:
  Link();
  virtual ~Link();

  Link(const Link& from);

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Link& default_instance();

  void Swap(Link* other);

  // implements Message ----------------------------------------------

  inline Link* New() const { return New(NULL); }

  Link* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Link& from);
  void MergeFrom(const Link& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Link* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fromNodeID = 4;
  inline bool has_fromnodeid() const;
  inline void clear_fromnodeid();
  static const int kFromNodeIDFieldNumber = 4;
  inline const ::std::string& fromnodeid() const;
  inline void set_fromnodeid(const ::std::string& value);
  inline void set_fromnodeid(const char* value);
  inline void set_fromnodeid(const char* value, size_t size);
  inline ::std::string* mutable_fromnodeid();
  inline ::std::string* release_fromnodeid();
  inline void set_allocated_fromnodeid(::std::string* fromnodeid);

  // required string toNodeID = 5;
  inline bool has_tonodeid() const;
  inline void clear_tonodeid();
  static const int kToNodeIDFieldNumber = 5;
  inline const ::std::string& tonodeid() const;
  inline void set_tonodeid(const ::std::string& value);
  inline void set_tonodeid(const char* value);
  inline void set_tonodeid(const char* value, size_t size);
  inline ::std::string* mutable_tonodeid();
  inline ::std::string* release_tonodeid();
  inline void set_allocated_tonodeid(::std::string* tonodeid);

  // @@protoc_insertion_point(class_scope:modeTable.Link)
 private:
  inline void set_has_fromnodeid();
  inline void clear_has_fromnodeid();
  inline void set_has_tonodeid();
  inline void clear_has_tonodeid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fromnodeid_;
  ::google::protobuf::internal::ArenaStringPtr tonodeid_;
  friend void  protobuf_AddDesc_modeTable_2eproto();
  friend void protobuf_AssignDesc_modeTable_2eproto();
  friend void protobuf_ShutdownFile_modeTable_2eproto();

  void InitAsDefaultInstance();
  static Link* default_instance_;
};
// -------------------------------------------------------------------

class MTFile : public ::google::protobuf::Message {
 public:
  MTFile();
  virtual ~MTFile();

  MTFile(const MTFile& from);

  inline MTFile& operator=(const MTFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MTFile& default_instance();

  void Swap(MTFile* other);

  // implements Message ----------------------------------------------

  inline MTFile* New() const { return New(NULL); }

  MTFile* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MTFile& from);
  void MergeFrom(const MTFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MTFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .modeTable.Node nodeList = 1;
  inline int nodelist_size() const;
  inline void clear_nodelist();
  static const int kNodeListFieldNumber = 1;
  inline const ::modeTable::Node& nodelist(int index) const;
  inline ::modeTable::Node* mutable_nodelist(int index);
  inline ::modeTable::Node* add_nodelist();
  inline const ::google::protobuf::RepeatedPtrField< ::modeTable::Node >&
      nodelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::modeTable::Node >*
      mutable_nodelist();

  // repeated .modeTable.Link LinkList = 2;
  inline int linklist_size() const;
  inline void clear_linklist();
  static const int kLinkListFieldNumber = 2;
  inline const ::modeTable::Link& linklist(int index) const;
  inline ::modeTable::Link* mutable_linklist(int index);
  inline ::modeTable::Link* add_linklist();
  inline const ::google::protobuf::RepeatedPtrField< ::modeTable::Link >&
      linklist() const;
  inline ::google::protobuf::RepeatedPtrField< ::modeTable::Link >*
      mutable_linklist();

  // @@protoc_insertion_point(class_scope:modeTable.MTFile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::modeTable::Node > nodelist_;
  ::google::protobuf::RepeatedPtrField< ::modeTable::Link > linklist_;
  friend void  protobuf_AddDesc_modeTable_2eproto();
  friend void protobuf_AssignDesc_modeTable_2eproto();
  friend void protobuf_ShutdownFile_modeTable_2eproto();

  void InitAsDefaultInstance();
  static MTFile* default_instance_;
};
// ===================================================================


// ===================================================================

// Node_GivenAudioPair

// required string givenCode = 1;
inline bool Node_GivenAudioPair::has_givencode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node_GivenAudioPair::set_has_givencode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node_GivenAudioPair::clear_has_givencode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node_GivenAudioPair::clear_givencode() {
  givencode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_givencode();
}
inline const ::std::string& Node_GivenAudioPair::givencode() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.GivenAudioPair.givenCode)
  return givencode_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node_GivenAudioPair::set_givencode(const ::std::string& value) {
  set_has_givencode();
  givencode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.GivenAudioPair.givenCode)
}
inline void Node_GivenAudioPair::set_givencode(const char* value) {
  set_has_givencode();
  givencode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.GivenAudioPair.givenCode)
}
inline void Node_GivenAudioPair::set_givencode(const char* value, size_t size) {
  set_has_givencode();
  givencode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.GivenAudioPair.givenCode)
}
inline ::std::string* Node_GivenAudioPair::mutable_givencode() {
  set_has_givencode();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.GivenAudioPair.givenCode)
  return givencode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node_GivenAudioPair::release_givencode() {
  clear_has_givencode();
  return givencode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node_GivenAudioPair::set_allocated_givencode(::std::string* givencode) {
  if (givencode != NULL) {
    set_has_givencode();
  } else {
    clear_has_givencode();
  }
  givencode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), givencode);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.GivenAudioPair.givenCode)
}

// required string givenAudio = 2;
inline bool Node_GivenAudioPair::has_givenaudio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node_GivenAudioPair::set_has_givenaudio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node_GivenAudioPair::clear_has_givenaudio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node_GivenAudioPair::clear_givenaudio() {
  givenaudio_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_givenaudio();
}
inline const ::std::string& Node_GivenAudioPair::givenaudio() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.GivenAudioPair.givenAudio)
  return givenaudio_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node_GivenAudioPair::set_givenaudio(const ::std::string& value) {
  set_has_givenaudio();
  givenaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.GivenAudioPair.givenAudio)
}
inline void Node_GivenAudioPair::set_givenaudio(const char* value) {
  set_has_givenaudio();
  givenaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.GivenAudioPair.givenAudio)
}
inline void Node_GivenAudioPair::set_givenaudio(const char* value, size_t size) {
  set_has_givenaudio();
  givenaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.GivenAudioPair.givenAudio)
}
inline ::std::string* Node_GivenAudioPair::mutable_givenaudio() {
  set_has_givenaudio();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.GivenAudioPair.givenAudio)
  return givenaudio_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node_GivenAudioPair::release_givenaudio() {
  clear_has_givenaudio();
  return givenaudio_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node_GivenAudioPair::set_allocated_givenaudio(::std::string* givenaudio) {
  if (givenaudio != NULL) {
    set_has_givenaudio();
  } else {
    clear_has_givenaudio();
  }
  givenaudio_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), givenaudio);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.GivenAudioPair.givenAudio)
}

// -------------------------------------------------------------------

// Node

// required double xPos = 1;
inline bool Node::has_xpos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_xpos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_xpos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_xpos() {
  xpos_ = 0;
  clear_has_xpos();
}
inline double Node::xpos() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.xPos)
  return xpos_;
}
inline void Node::set_xpos(double value) {
  set_has_xpos();
  xpos_ = value;
  // @@protoc_insertion_point(field_set:modeTable.Node.xPos)
}

// required double yPos = 2;
inline bool Node::has_ypos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_ypos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_ypos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_ypos() {
  ypos_ = 0;
  clear_has_ypos();
}
inline double Node::ypos() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.yPos)
  return ypos_;
}
inline void Node::set_ypos(double value) {
  set_has_ypos();
  ypos_ = value;
  // @@protoc_insertion_point(field_set:modeTable.Node.yPos)
}

// required string nodeName = 3;
inline bool Node::has_nodename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node::set_has_nodename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node::clear_has_nodename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node::clear_nodename() {
  nodename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nodename();
}
inline const ::std::string& Node::nodename() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.nodeName)
  return nodename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_nodename(const ::std::string& value) {
  set_has_nodename();
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.nodeName)
}
inline void Node::set_nodename(const char* value) {
  set_has_nodename();
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.nodeName)
}
inline void Node::set_nodename(const char* value, size_t size) {
  set_has_nodename();
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.nodeName)
}
inline ::std::string* Node::mutable_nodename() {
  set_has_nodename();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.nodeName)
  return nodename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_nodename() {
  clear_has_nodename();
  return nodename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_nodename(::std::string* nodename) {
  if (nodename != NULL) {
    set_has_nodename();
  } else {
    clear_has_nodename();
  }
  nodename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodename);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.nodeName)
}

// required string textColor = 4;
inline bool Node::has_textcolor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Node::set_has_textcolor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Node::clear_has_textcolor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Node::clear_textcolor() {
  textcolor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_textcolor();
}
inline const ::std::string& Node::textcolor() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.textColor)
  return textcolor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_textcolor(const ::std::string& value) {
  set_has_textcolor();
  textcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.textColor)
}
inline void Node::set_textcolor(const char* value) {
  set_has_textcolor();
  textcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.textColor)
}
inline void Node::set_textcolor(const char* value, size_t size) {
  set_has_textcolor();
  textcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.textColor)
}
inline ::std::string* Node::mutable_textcolor() {
  set_has_textcolor();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.textColor)
  return textcolor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_textcolor() {
  clear_has_textcolor();
  return textcolor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_textcolor(::std::string* textcolor) {
  if (textcolor != NULL) {
    set_has_textcolor();
  } else {
    clear_has_textcolor();
  }
  textcolor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), textcolor);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.textColor)
}

// required string outlineColor = 5;
inline bool Node::has_outlinecolor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Node::set_has_outlinecolor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Node::clear_has_outlinecolor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Node::clear_outlinecolor() {
  outlinecolor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_outlinecolor();
}
inline const ::std::string& Node::outlinecolor() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.outlineColor)
  return outlinecolor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_outlinecolor(const ::std::string& value) {
  set_has_outlinecolor();
  outlinecolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.outlineColor)
}
inline void Node::set_outlinecolor(const char* value) {
  set_has_outlinecolor();
  outlinecolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.outlineColor)
}
inline void Node::set_outlinecolor(const char* value, size_t size) {
  set_has_outlinecolor();
  outlinecolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.outlineColor)
}
inline ::std::string* Node::mutable_outlinecolor() {
  set_has_outlinecolor();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.outlineColor)
  return outlinecolor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_outlinecolor() {
  clear_has_outlinecolor();
  return outlinecolor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_outlinecolor(::std::string* outlinecolor) {
  if (outlinecolor != NULL) {
    set_has_outlinecolor();
  } else {
    clear_has_outlinecolor();
  }
  outlinecolor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), outlinecolor);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.outlineColor)
}

// required string backgroundColor = 6;
inline bool Node::has_backgroundcolor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Node::set_has_backgroundcolor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Node::clear_has_backgroundcolor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Node::clear_backgroundcolor() {
  backgroundcolor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_backgroundcolor();
}
inline const ::std::string& Node::backgroundcolor() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.backgroundColor)
  return backgroundcolor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_backgroundcolor(const ::std::string& value) {
  set_has_backgroundcolor();
  backgroundcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.backgroundColor)
}
inline void Node::set_backgroundcolor(const char* value) {
  set_has_backgroundcolor();
  backgroundcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.backgroundColor)
}
inline void Node::set_backgroundcolor(const char* value, size_t size) {
  set_has_backgroundcolor();
  backgroundcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.backgroundColor)
}
inline ::std::string* Node::mutable_backgroundcolor() {
  set_has_backgroundcolor();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.backgroundColor)
  return backgroundcolor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_backgroundcolor() {
  clear_has_backgroundcolor();
  return backgroundcolor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_backgroundcolor(::std::string* backgroundcolor) {
  if (backgroundcolor != NULL) {
    set_has_backgroundcolor();
  } else {
    clear_has_backgroundcolor();
  }
  backgroundcolor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), backgroundcolor);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.backgroundColor)
}

// required string transCodeTextColor = 7;
inline bool Node::has_transcodetextcolor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Node::set_has_transcodetextcolor() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Node::clear_has_transcodetextcolor() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Node::clear_transcodetextcolor() {
  transcodetextcolor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_transcodetextcolor();
}
inline const ::std::string& Node::transcodetextcolor() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.transCodeTextColor)
  return transcodetextcolor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_transcodetextcolor(const ::std::string& value) {
  set_has_transcodetextcolor();
  transcodetextcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.transCodeTextColor)
}
inline void Node::set_transcodetextcolor(const char* value) {
  set_has_transcodetextcolor();
  transcodetextcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.transCodeTextColor)
}
inline void Node::set_transcodetextcolor(const char* value, size_t size) {
  set_has_transcodetextcolor();
  transcodetextcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.transCodeTextColor)
}
inline ::std::string* Node::mutable_transcodetextcolor() {
  set_has_transcodetextcolor();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.transCodeTextColor)
  return transcodetextcolor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_transcodetextcolor() {
  clear_has_transcodetextcolor();
  return transcodetextcolor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_transcodetextcolor(::std::string* transcodetextcolor) {
  if (transcodetextcolor != NULL) {
    set_has_transcodetextcolor();
  } else {
    clear_has_transcodetextcolor();
  }
  transcodetextcolor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transcodetextcolor);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.transCodeTextColor)
}

// required string transCodeBackgroundColor = 8;
inline bool Node::has_transcodebackgroundcolor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Node::set_has_transcodebackgroundcolor() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Node::clear_has_transcodebackgroundcolor() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Node::clear_transcodebackgroundcolor() {
  transcodebackgroundcolor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_transcodebackgroundcolor();
}
inline const ::std::string& Node::transcodebackgroundcolor() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.transCodeBackgroundColor)
  return transcodebackgroundcolor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_transcodebackgroundcolor(const ::std::string& value) {
  set_has_transcodebackgroundcolor();
  transcodebackgroundcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.transCodeBackgroundColor)
}
inline void Node::set_transcodebackgroundcolor(const char* value) {
  set_has_transcodebackgroundcolor();
  transcodebackgroundcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.transCodeBackgroundColor)
}
inline void Node::set_transcodebackgroundcolor(const char* value, size_t size) {
  set_has_transcodebackgroundcolor();
  transcodebackgroundcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.transCodeBackgroundColor)
}
inline ::std::string* Node::mutable_transcodebackgroundcolor() {
  set_has_transcodebackgroundcolor();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.transCodeBackgroundColor)
  return transcodebackgroundcolor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_transcodebackgroundcolor() {
  clear_has_transcodebackgroundcolor();
  return transcodebackgroundcolor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_transcodebackgroundcolor(::std::string* transcodebackgroundcolor) {
  if (transcodebackgroundcolor != NULL) {
    set_has_transcodebackgroundcolor();
  } else {
    clear_has_transcodebackgroundcolor();
  }
  transcodebackgroundcolor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transcodebackgroundcolor);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.transCodeBackgroundColor)
}

// optional string startAudio = 9;
inline bool Node::has_startaudio() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Node::set_has_startaudio() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Node::clear_has_startaudio() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Node::clear_startaudio() {
  startaudio_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_startaudio();
}
inline const ::std::string& Node::startaudio() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.startAudio)
  return startaudio_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_startaudio(const ::std::string& value) {
  set_has_startaudio();
  startaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.startAudio)
}
inline void Node::set_startaudio(const char* value) {
  set_has_startaudio();
  startaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.startAudio)
}
inline void Node::set_startaudio(const char* value, size_t size) {
  set_has_startaudio();
  startaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.startAudio)
}
inline ::std::string* Node::mutable_startaudio() {
  set_has_startaudio();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.startAudio)
  return startaudio_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_startaudio() {
  clear_has_startaudio();
  return startaudio_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_startaudio(::std::string* startaudio) {
  if (startaudio != NULL) {
    set_has_startaudio();
  } else {
    clear_has_startaudio();
  }
  startaudio_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), startaudio);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.startAudio)
}

// optional string endAudio = 10;
inline bool Node::has_endaudio() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Node::set_has_endaudio() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Node::clear_has_endaudio() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Node::clear_endaudio() {
  endaudio_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_endaudio();
}
inline const ::std::string& Node::endaudio() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.endAudio)
  return endaudio_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_endaudio(const ::std::string& value) {
  set_has_endaudio();
  endaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.endAudio)
}
inline void Node::set_endaudio(const char* value) {
  set_has_endaudio();
  endaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.endAudio)
}
inline void Node::set_endaudio(const char* value, size_t size) {
  set_has_endaudio();
  endaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.endAudio)
}
inline ::std::string* Node::mutable_endaudio() {
  set_has_endaudio();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.endAudio)
  return endaudio_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_endaudio() {
  clear_has_endaudio();
  return endaudio_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_endaudio(::std::string* endaudio) {
  if (endaudio != NULL) {
    set_has_endaudio();
  } else {
    clear_has_endaudio();
  }
  endaudio_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), endaudio);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.endAudio)
}

// optional string transCode = 11;
inline bool Node::has_transcode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Node::set_has_transcode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Node::clear_has_transcode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Node::clear_transcode() {
  transcode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_transcode();
}
inline const ::std::string& Node::transcode() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.transCode)
  return transcode_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_transcode(const ::std::string& value) {
  set_has_transcode();
  transcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.transCode)
}
inline void Node::set_transcode(const char* value) {
  set_has_transcode();
  transcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.transCode)
}
inline void Node::set_transcode(const char* value, size_t size) {
  set_has_transcode();
  transcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.transCode)
}
inline ::std::string* Node::mutable_transcode() {
  set_has_transcode();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.transCode)
  return transcode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_transcode() {
  clear_has_transcode();
  return transcode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_transcode(::std::string* transcode) {
  if (transcode != NULL) {
    set_has_transcode();
  } else {
    clear_has_transcode();
  }
  transcode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transcode);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.transCode)
}

// optional string pictureFile = 12;
inline bool Node::has_picturefile() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Node::set_has_picturefile() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Node::clear_has_picturefile() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Node::clear_picturefile() {
  picturefile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_picturefile();
}
inline const ::std::string& Node::picturefile() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.pictureFile)
  return picturefile_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_picturefile(const ::std::string& value) {
  set_has_picturefile();
  picturefile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.pictureFile)
}
inline void Node::set_picturefile(const char* value) {
  set_has_picturefile();
  picturefile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.pictureFile)
}
inline void Node::set_picturefile(const char* value, size_t size) {
  set_has_picturefile();
  picturefile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.pictureFile)
}
inline ::std::string* Node::mutable_picturefile() {
  set_has_picturefile();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.pictureFile)
  return picturefile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_picturefile() {
  clear_has_picturefile();
  return picturefile_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_picturefile(::std::string* picturefile) {
  if (picturefile != NULL) {
    set_has_picturefile();
  } else {
    clear_has_picturefile();
  }
  picturefile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), picturefile);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.pictureFile)
}

// repeated .modeTable.Node.GivenAudioPair givenAudios = 13;
inline int Node::givenaudios_size() const {
  return givenaudios_.size();
}
inline void Node::clear_givenaudios() {
  givenaudios_.Clear();
}
inline const ::modeTable::Node_GivenAudioPair& Node::givenaudios(int index) const {
  // @@protoc_insertion_point(field_get:modeTable.Node.givenAudios)
  return givenaudios_.Get(index);
}
inline ::modeTable::Node_GivenAudioPair* Node::mutable_givenaudios(int index) {
  // @@protoc_insertion_point(field_mutable:modeTable.Node.givenAudios)
  return givenaudios_.Mutable(index);
}
inline ::modeTable::Node_GivenAudioPair* Node::add_givenaudios() {
  // @@protoc_insertion_point(field_add:modeTable.Node.givenAudios)
  return givenaudios_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::modeTable::Node_GivenAudioPair >&
Node::givenaudios() const {
  // @@protoc_insertion_point(field_list:modeTable.Node.givenAudios)
  return givenaudios_;
}
inline ::google::protobuf::RepeatedPtrField< ::modeTable::Node_GivenAudioPair >*
Node::mutable_givenaudios() {
  // @@protoc_insertion_point(field_mutable_list:modeTable.Node.givenAudios)
  return &givenaudios_;
}

// required string nodeID = 14;
inline bool Node::has_nodeid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Node::set_has_nodeid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Node::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Node::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nodeid();
}
inline const ::std::string& Node::nodeid() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.nodeID)
  return nodeid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.nodeID)
}
inline void Node::set_nodeid(const char* value) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.nodeID)
}
inline void Node::set_nodeid(const char* value, size_t size) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.nodeID)
}
inline ::std::string* Node::mutable_nodeid() {
  set_has_nodeid();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.nodeID)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_nodeid() {
  clear_has_nodeid();
  return nodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    set_has_nodeid();
  } else {
    clear_has_nodeid();
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.nodeID)
}

// -------------------------------------------------------------------

// Link

// required string fromNodeID = 4;
inline bool Link::has_fromnodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Link::set_has_fromnodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Link::clear_has_fromnodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Link::clear_fromnodeid() {
  fromnodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fromnodeid();
}
inline const ::std::string& Link::fromnodeid() const {
  // @@protoc_insertion_point(field_get:modeTable.Link.fromNodeID)
  return fromnodeid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_fromnodeid(const ::std::string& value) {
  set_has_fromnodeid();
  fromnodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Link.fromNodeID)
}
inline void Link::set_fromnodeid(const char* value) {
  set_has_fromnodeid();
  fromnodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Link.fromNodeID)
}
inline void Link::set_fromnodeid(const char* value, size_t size) {
  set_has_fromnodeid();
  fromnodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Link.fromNodeID)
}
inline ::std::string* Link::mutable_fromnodeid() {
  set_has_fromnodeid();
  // @@protoc_insertion_point(field_mutable:modeTable.Link.fromNodeID)
  return fromnodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Link::release_fromnodeid() {
  clear_has_fromnodeid();
  return fromnodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_allocated_fromnodeid(::std::string* fromnodeid) {
  if (fromnodeid != NULL) {
    set_has_fromnodeid();
  } else {
    clear_has_fromnodeid();
  }
  fromnodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fromnodeid);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Link.fromNodeID)
}

// required string toNodeID = 5;
inline bool Link::has_tonodeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Link::set_has_tonodeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Link::clear_has_tonodeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Link::clear_tonodeid() {
  tonodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tonodeid();
}
inline const ::std::string& Link::tonodeid() const {
  // @@protoc_insertion_point(field_get:modeTable.Link.toNodeID)
  return tonodeid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_tonodeid(const ::std::string& value) {
  set_has_tonodeid();
  tonodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Link.toNodeID)
}
inline void Link::set_tonodeid(const char* value) {
  set_has_tonodeid();
  tonodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Link.toNodeID)
}
inline void Link::set_tonodeid(const char* value, size_t size) {
  set_has_tonodeid();
  tonodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Link.toNodeID)
}
inline ::std::string* Link::mutable_tonodeid() {
  set_has_tonodeid();
  // @@protoc_insertion_point(field_mutable:modeTable.Link.toNodeID)
  return tonodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Link::release_tonodeid() {
  clear_has_tonodeid();
  return tonodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_allocated_tonodeid(::std::string* tonodeid) {
  if (tonodeid != NULL) {
    set_has_tonodeid();
  } else {
    clear_has_tonodeid();
  }
  tonodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tonodeid);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Link.toNodeID)
}

// -------------------------------------------------------------------

// MTFile

// repeated .modeTable.Node nodeList = 1;
inline int MTFile::nodelist_size() const {
  return nodelist_.size();
}
inline void MTFile::clear_nodelist() {
  nodelist_.Clear();
}
inline const ::modeTable::Node& MTFile::nodelist(int index) const {
  // @@protoc_insertion_point(field_get:modeTable.MTFile.nodeList)
  return nodelist_.Get(index);
}
inline ::modeTable::Node* MTFile::mutable_nodelist(int index) {
  // @@protoc_insertion_point(field_mutable:modeTable.MTFile.nodeList)
  return nodelist_.Mutable(index);
}
inline ::modeTable::Node* MTFile::add_nodelist() {
  // @@protoc_insertion_point(field_add:modeTable.MTFile.nodeList)
  return nodelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::modeTable::Node >&
MTFile::nodelist() const {
  // @@protoc_insertion_point(field_list:modeTable.MTFile.nodeList)
  return nodelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::modeTable::Node >*
MTFile::mutable_nodelist() {
  // @@protoc_insertion_point(field_mutable_list:modeTable.MTFile.nodeList)
  return &nodelist_;
}

// repeated .modeTable.Link LinkList = 2;
inline int MTFile::linklist_size() const {
  return linklist_.size();
}
inline void MTFile::clear_linklist() {
  linklist_.Clear();
}
inline const ::modeTable::Link& MTFile::linklist(int index) const {
  // @@protoc_insertion_point(field_get:modeTable.MTFile.LinkList)
  return linklist_.Get(index);
}
inline ::modeTable::Link* MTFile::mutable_linklist(int index) {
  // @@protoc_insertion_point(field_mutable:modeTable.MTFile.LinkList)
  return linklist_.Mutable(index);
}
inline ::modeTable::Link* MTFile::add_linklist() {
  // @@protoc_insertion_point(field_add:modeTable.MTFile.LinkList)
  return linklist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::modeTable::Link >&
MTFile::linklist() const {
  // @@protoc_insertion_point(field_list:modeTable.MTFile.LinkList)
  return linklist_;
}
inline ::google::protobuf::RepeatedPtrField< ::modeTable::Link >*
MTFile::mutable_linklist() {
  // @@protoc_insertion_point(field_mutable_list:modeTable.MTFile.LinkList)
  return &linklist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace modeTable

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modeTable_2eproto__INCLUDED
