// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modeTable.proto

#ifndef PROTOBUF_modeTable_2eproto__INCLUDED
#define PROTOBUF_modeTable_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace modeTable {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_modeTable_2eproto();
void protobuf_AssignDesc_modeTable_2eproto();
void protobuf_ShutdownFile_modeTable_2eproto();

class Node;
class Link;
class MTFile;

// ===================================================================

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  inline Node* New() const { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double xPos = 1;
  inline bool has_xpos() const;
  inline void clear_xpos();
  static const int kXPosFieldNumber = 1;
  inline double xpos() const;
  inline void set_xpos(double value);

  // required double yPos = 2;
  inline bool has_ypos() const;
  inline void clear_ypos();
  static const int kYPosFieldNumber = 2;
  inline double ypos() const;
  inline void set_ypos(double value);

  // required string nodeName = 3;
  inline bool has_nodename() const;
  inline void clear_nodename();
  static const int kNodeNameFieldNumber = 3;
  inline const ::std::string& nodename() const;
  inline void set_nodename(const ::std::string& value);
  inline void set_nodename(const char* value);
  inline void set_nodename(const char* value, size_t size);
  inline ::std::string* mutable_nodename();
  inline ::std::string* release_nodename();
  inline void set_allocated_nodename(::std::string* nodename);

  // required string textColor = 4;
  inline bool has_textcolor() const;
  inline void clear_textcolor();
  static const int kTextColorFieldNumber = 4;
  inline const ::std::string& textcolor() const;
  inline void set_textcolor(const ::std::string& value);
  inline void set_textcolor(const char* value);
  inline void set_textcolor(const char* value, size_t size);
  inline ::std::string* mutable_textcolor();
  inline ::std::string* release_textcolor();
  inline void set_allocated_textcolor(::std::string* textcolor);

  // required string outlineColor = 5;
  inline bool has_outlinecolor() const;
  inline void clear_outlinecolor();
  static const int kOutlineColorFieldNumber = 5;
  inline const ::std::string& outlinecolor() const;
  inline void set_outlinecolor(const ::std::string& value);
  inline void set_outlinecolor(const char* value);
  inline void set_outlinecolor(const char* value, size_t size);
  inline ::std::string* mutable_outlinecolor();
  inline ::std::string* release_outlinecolor();
  inline void set_allocated_outlinecolor(::std::string* outlinecolor);

  // required string backgroundColor = 6;
  inline bool has_backgroundcolor() const;
  inline void clear_backgroundcolor();
  static const int kBackgroundColorFieldNumber = 6;
  inline const ::std::string& backgroundcolor() const;
  inline void set_backgroundcolor(const ::std::string& value);
  inline void set_backgroundcolor(const char* value);
  inline void set_backgroundcolor(const char* value, size_t size);
  inline ::std::string* mutable_backgroundcolor();
  inline ::std::string* release_backgroundcolor();
  inline void set_allocated_backgroundcolor(::std::string* backgroundcolor);

  // optional string startAudio = 7;
  inline bool has_startaudio() const;
  inline void clear_startaudio();
  static const int kStartAudioFieldNumber = 7;
  inline const ::std::string& startaudio() const;
  inline void set_startaudio(const ::std::string& value);
  inline void set_startaudio(const char* value);
  inline void set_startaudio(const char* value, size_t size);
  inline ::std::string* mutable_startaudio();
  inline ::std::string* release_startaudio();
  inline void set_allocated_startaudio(::std::string* startaudio);

  // optional string endAudio = 8;
  inline bool has_endaudio() const;
  inline void clear_endaudio();
  static const int kEndAudioFieldNumber = 8;
  inline const ::std::string& endaudio() const;
  inline void set_endaudio(const ::std::string& value);
  inline void set_endaudio(const char* value);
  inline void set_endaudio(const char* value, size_t size);
  inline ::std::string* mutable_endaudio();
  inline ::std::string* release_endaudio();
  inline void set_allocated_endaudio(::std::string* endaudio);

  // repeated string defaultAudio = 9;
  inline int defaultaudio_size() const;
  inline void clear_defaultaudio();
  static const int kDefaultAudioFieldNumber = 9;
  inline const ::std::string& defaultaudio(int index) const;
  inline ::std::string* mutable_defaultaudio(int index);
  inline void set_defaultaudio(int index, const ::std::string& value);
  inline void set_defaultaudio(int index, const char* value);
  inline void set_defaultaudio(int index, const char* value, size_t size);
  inline ::std::string* add_defaultaudio();
  inline void add_defaultaudio(const ::std::string& value);
  inline void add_defaultaudio(const char* value);
  inline void add_defaultaudio(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& defaultaudio() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_defaultaudio();

  // required string nodeID = 10;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIDFieldNumber = 10;
  inline const ::std::string& nodeid() const;
  inline void set_nodeid(const ::std::string& value);
  inline void set_nodeid(const char* value);
  inline void set_nodeid(const char* value, size_t size);
  inline ::std::string* mutable_nodeid();
  inline ::std::string* release_nodeid();
  inline void set_allocated_nodeid(::std::string* nodeid);

  // @@protoc_insertion_point(class_scope:modeTable.Node)
 private:
  inline void set_has_xpos();
  inline void clear_has_xpos();
  inline void set_has_ypos();
  inline void clear_has_ypos();
  inline void set_has_nodename();
  inline void clear_has_nodename();
  inline void set_has_textcolor();
  inline void clear_has_textcolor();
  inline void set_has_outlinecolor();
  inline void clear_has_outlinecolor();
  inline void set_has_backgroundcolor();
  inline void clear_has_backgroundcolor();
  inline void set_has_startaudio();
  inline void clear_has_startaudio();
  inline void set_has_endaudio();
  inline void clear_has_endaudio();
  inline void set_has_nodeid();
  inline void clear_has_nodeid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double xpos_;
  double ypos_;
  ::google::protobuf::internal::ArenaStringPtr nodename_;
  ::google::protobuf::internal::ArenaStringPtr textcolor_;
  ::google::protobuf::internal::ArenaStringPtr outlinecolor_;
  ::google::protobuf::internal::ArenaStringPtr backgroundcolor_;
  ::google::protobuf::internal::ArenaStringPtr startaudio_;
  ::google::protobuf::internal::ArenaStringPtr endaudio_;
  ::google::protobuf::RepeatedPtrField< ::std::string> defaultaudio_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  friend void  protobuf_AddDesc_modeTable_2eproto();
  friend void protobuf_AssignDesc_modeTable_2eproto();
  friend void protobuf_ShutdownFile_modeTable_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class Link : public ::google::protobuf::Message {
 public:
  Link();
  virtual ~Link();

  Link(const Link& from);

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Link& default_instance();

  void Swap(Link* other);

  // implements Message ----------------------------------------------

  inline Link* New() const { return New(NULL); }

  Link* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Link& from);
  void MergeFrom(const Link& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Link* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 transCode = 1;
  inline bool has_transcode() const;
  inline void clear_transcode();
  static const int kTransCodeFieldNumber = 1;
  inline ::google::protobuf::int32 transcode() const;
  inline void set_transcode(::google::protobuf::int32 value);

  // required string fromNodeID = 4;
  inline bool has_fromnodeid() const;
  inline void clear_fromnodeid();
  static const int kFromNodeIDFieldNumber = 4;
  inline const ::std::string& fromnodeid() const;
  inline void set_fromnodeid(const ::std::string& value);
  inline void set_fromnodeid(const char* value);
  inline void set_fromnodeid(const char* value, size_t size);
  inline ::std::string* mutable_fromnodeid();
  inline ::std::string* release_fromnodeid();
  inline void set_allocated_fromnodeid(::std::string* fromnodeid);

  // required string toNodeID = 5;
  inline bool has_tonodeid() const;
  inline void clear_tonodeid();
  static const int kToNodeIDFieldNumber = 5;
  inline const ::std::string& tonodeid() const;
  inline void set_tonodeid(const ::std::string& value);
  inline void set_tonodeid(const char* value);
  inline void set_tonodeid(const char* value, size_t size);
  inline ::std::string* mutable_tonodeid();
  inline ::std::string* release_tonodeid();
  inline void set_allocated_tonodeid(::std::string* tonodeid);

  // @@protoc_insertion_point(class_scope:modeTable.Link)
 private:
  inline void set_has_transcode();
  inline void clear_has_transcode();
  inline void set_has_fromnodeid();
  inline void clear_has_fromnodeid();
  inline void set_has_tonodeid();
  inline void clear_has_tonodeid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fromnodeid_;
  ::google::protobuf::internal::ArenaStringPtr tonodeid_;
  ::google::protobuf::int32 transcode_;
  friend void  protobuf_AddDesc_modeTable_2eproto();
  friend void protobuf_AssignDesc_modeTable_2eproto();
  friend void protobuf_ShutdownFile_modeTable_2eproto();

  void InitAsDefaultInstance();
  static Link* default_instance_;
};
// -------------------------------------------------------------------

class MTFile : public ::google::protobuf::Message {
 public:
  MTFile();
  virtual ~MTFile();

  MTFile(const MTFile& from);

  inline MTFile& operator=(const MTFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MTFile& default_instance();

  void Swap(MTFile* other);

  // implements Message ----------------------------------------------

  inline MTFile* New() const { return New(NULL); }

  MTFile* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MTFile& from);
  void MergeFrom(const MTFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MTFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .modeTable.Node nodeList = 1;
  inline int nodelist_size() const;
  inline void clear_nodelist();
  static const int kNodeListFieldNumber = 1;
  inline const ::modeTable::Node& nodelist(int index) const;
  inline ::modeTable::Node* mutable_nodelist(int index);
  inline ::modeTable::Node* add_nodelist();
  inline const ::google::protobuf::RepeatedPtrField< ::modeTable::Node >&
      nodelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::modeTable::Node >*
      mutable_nodelist();

  // repeated .modeTable.Link LinkList = 2;
  inline int linklist_size() const;
  inline void clear_linklist();
  static const int kLinkListFieldNumber = 2;
  inline const ::modeTable::Link& linklist(int index) const;
  inline ::modeTable::Link* mutable_linklist(int index);
  inline ::modeTable::Link* add_linklist();
  inline const ::google::protobuf::RepeatedPtrField< ::modeTable::Link >&
      linklist() const;
  inline ::google::protobuf::RepeatedPtrField< ::modeTable::Link >*
      mutable_linklist();

  // @@protoc_insertion_point(class_scope:modeTable.MTFile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::modeTable::Node > nodelist_;
  ::google::protobuf::RepeatedPtrField< ::modeTable::Link > linklist_;
  friend void  protobuf_AddDesc_modeTable_2eproto();
  friend void protobuf_AssignDesc_modeTable_2eproto();
  friend void protobuf_ShutdownFile_modeTable_2eproto();

  void InitAsDefaultInstance();
  static MTFile* default_instance_;
};
// ===================================================================


// ===================================================================

// Node

// required double xPos = 1;
inline bool Node::has_xpos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_xpos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_xpos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_xpos() {
  xpos_ = 0;
  clear_has_xpos();
}
inline double Node::xpos() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.xPos)
  return xpos_;
}
inline void Node::set_xpos(double value) {
  set_has_xpos();
  xpos_ = value;
  // @@protoc_insertion_point(field_set:modeTable.Node.xPos)
}

// required double yPos = 2;
inline bool Node::has_ypos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_ypos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_ypos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_ypos() {
  ypos_ = 0;
  clear_has_ypos();
}
inline double Node::ypos() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.yPos)
  return ypos_;
}
inline void Node::set_ypos(double value) {
  set_has_ypos();
  ypos_ = value;
  // @@protoc_insertion_point(field_set:modeTable.Node.yPos)
}

// required string nodeName = 3;
inline bool Node::has_nodename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node::set_has_nodename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node::clear_has_nodename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node::clear_nodename() {
  nodename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nodename();
}
inline const ::std::string& Node::nodename() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.nodeName)
  return nodename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_nodename(const ::std::string& value) {
  set_has_nodename();
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.nodeName)
}
inline void Node::set_nodename(const char* value) {
  set_has_nodename();
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.nodeName)
}
inline void Node::set_nodename(const char* value, size_t size) {
  set_has_nodename();
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.nodeName)
}
inline ::std::string* Node::mutable_nodename() {
  set_has_nodename();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.nodeName)
  return nodename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_nodename() {
  clear_has_nodename();
  return nodename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_nodename(::std::string* nodename) {
  if (nodename != NULL) {
    set_has_nodename();
  } else {
    clear_has_nodename();
  }
  nodename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodename);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.nodeName)
}

// required string textColor = 4;
inline bool Node::has_textcolor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Node::set_has_textcolor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Node::clear_has_textcolor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Node::clear_textcolor() {
  textcolor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_textcolor();
}
inline const ::std::string& Node::textcolor() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.textColor)
  return textcolor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_textcolor(const ::std::string& value) {
  set_has_textcolor();
  textcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.textColor)
}
inline void Node::set_textcolor(const char* value) {
  set_has_textcolor();
  textcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.textColor)
}
inline void Node::set_textcolor(const char* value, size_t size) {
  set_has_textcolor();
  textcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.textColor)
}
inline ::std::string* Node::mutable_textcolor() {
  set_has_textcolor();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.textColor)
  return textcolor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_textcolor() {
  clear_has_textcolor();
  return textcolor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_textcolor(::std::string* textcolor) {
  if (textcolor != NULL) {
    set_has_textcolor();
  } else {
    clear_has_textcolor();
  }
  textcolor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), textcolor);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.textColor)
}

// required string outlineColor = 5;
inline bool Node::has_outlinecolor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Node::set_has_outlinecolor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Node::clear_has_outlinecolor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Node::clear_outlinecolor() {
  outlinecolor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_outlinecolor();
}
inline const ::std::string& Node::outlinecolor() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.outlineColor)
  return outlinecolor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_outlinecolor(const ::std::string& value) {
  set_has_outlinecolor();
  outlinecolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.outlineColor)
}
inline void Node::set_outlinecolor(const char* value) {
  set_has_outlinecolor();
  outlinecolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.outlineColor)
}
inline void Node::set_outlinecolor(const char* value, size_t size) {
  set_has_outlinecolor();
  outlinecolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.outlineColor)
}
inline ::std::string* Node::mutable_outlinecolor() {
  set_has_outlinecolor();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.outlineColor)
  return outlinecolor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_outlinecolor() {
  clear_has_outlinecolor();
  return outlinecolor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_outlinecolor(::std::string* outlinecolor) {
  if (outlinecolor != NULL) {
    set_has_outlinecolor();
  } else {
    clear_has_outlinecolor();
  }
  outlinecolor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), outlinecolor);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.outlineColor)
}

// required string backgroundColor = 6;
inline bool Node::has_backgroundcolor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Node::set_has_backgroundcolor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Node::clear_has_backgroundcolor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Node::clear_backgroundcolor() {
  backgroundcolor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_backgroundcolor();
}
inline const ::std::string& Node::backgroundcolor() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.backgroundColor)
  return backgroundcolor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_backgroundcolor(const ::std::string& value) {
  set_has_backgroundcolor();
  backgroundcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.backgroundColor)
}
inline void Node::set_backgroundcolor(const char* value) {
  set_has_backgroundcolor();
  backgroundcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.backgroundColor)
}
inline void Node::set_backgroundcolor(const char* value, size_t size) {
  set_has_backgroundcolor();
  backgroundcolor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.backgroundColor)
}
inline ::std::string* Node::mutable_backgroundcolor() {
  set_has_backgroundcolor();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.backgroundColor)
  return backgroundcolor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_backgroundcolor() {
  clear_has_backgroundcolor();
  return backgroundcolor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_backgroundcolor(::std::string* backgroundcolor) {
  if (backgroundcolor != NULL) {
    set_has_backgroundcolor();
  } else {
    clear_has_backgroundcolor();
  }
  backgroundcolor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), backgroundcolor);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.backgroundColor)
}

// optional string startAudio = 7;
inline bool Node::has_startaudio() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Node::set_has_startaudio() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Node::clear_has_startaudio() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Node::clear_startaudio() {
  startaudio_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_startaudio();
}
inline const ::std::string& Node::startaudio() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.startAudio)
  return startaudio_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_startaudio(const ::std::string& value) {
  set_has_startaudio();
  startaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.startAudio)
}
inline void Node::set_startaudio(const char* value) {
  set_has_startaudio();
  startaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.startAudio)
}
inline void Node::set_startaudio(const char* value, size_t size) {
  set_has_startaudio();
  startaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.startAudio)
}
inline ::std::string* Node::mutable_startaudio() {
  set_has_startaudio();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.startAudio)
  return startaudio_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_startaudio() {
  clear_has_startaudio();
  return startaudio_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_startaudio(::std::string* startaudio) {
  if (startaudio != NULL) {
    set_has_startaudio();
  } else {
    clear_has_startaudio();
  }
  startaudio_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), startaudio);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.startAudio)
}

// optional string endAudio = 8;
inline bool Node::has_endaudio() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Node::set_has_endaudio() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Node::clear_has_endaudio() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Node::clear_endaudio() {
  endaudio_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_endaudio();
}
inline const ::std::string& Node::endaudio() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.endAudio)
  return endaudio_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_endaudio(const ::std::string& value) {
  set_has_endaudio();
  endaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.endAudio)
}
inline void Node::set_endaudio(const char* value) {
  set_has_endaudio();
  endaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.endAudio)
}
inline void Node::set_endaudio(const char* value, size_t size) {
  set_has_endaudio();
  endaudio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.endAudio)
}
inline ::std::string* Node::mutable_endaudio() {
  set_has_endaudio();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.endAudio)
  return endaudio_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_endaudio() {
  clear_has_endaudio();
  return endaudio_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_endaudio(::std::string* endaudio) {
  if (endaudio != NULL) {
    set_has_endaudio();
  } else {
    clear_has_endaudio();
  }
  endaudio_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), endaudio);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.endAudio)
}

// repeated string defaultAudio = 9;
inline int Node::defaultaudio_size() const {
  return defaultaudio_.size();
}
inline void Node::clear_defaultaudio() {
  defaultaudio_.Clear();
}
inline const ::std::string& Node::defaultaudio(int index) const {
  // @@protoc_insertion_point(field_get:modeTable.Node.defaultAudio)
  return defaultaudio_.Get(index);
}
inline ::std::string* Node::mutable_defaultaudio(int index) {
  // @@protoc_insertion_point(field_mutable:modeTable.Node.defaultAudio)
  return defaultaudio_.Mutable(index);
}
inline void Node::set_defaultaudio(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:modeTable.Node.defaultAudio)
  defaultaudio_.Mutable(index)->assign(value);
}
inline void Node::set_defaultaudio(int index, const char* value) {
  defaultaudio_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:modeTable.Node.defaultAudio)
}
inline void Node::set_defaultaudio(int index, const char* value, size_t size) {
  defaultaudio_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.defaultAudio)
}
inline ::std::string* Node::add_defaultaudio() {
  return defaultaudio_.Add();
}
inline void Node::add_defaultaudio(const ::std::string& value) {
  defaultaudio_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:modeTable.Node.defaultAudio)
}
inline void Node::add_defaultaudio(const char* value) {
  defaultaudio_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:modeTable.Node.defaultAudio)
}
inline void Node::add_defaultaudio(const char* value, size_t size) {
  defaultaudio_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:modeTable.Node.defaultAudio)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Node::defaultaudio() const {
  // @@protoc_insertion_point(field_list:modeTable.Node.defaultAudio)
  return defaultaudio_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Node::mutable_defaultaudio() {
  // @@protoc_insertion_point(field_mutable_list:modeTable.Node.defaultAudio)
  return &defaultaudio_;
}

// required string nodeID = 10;
inline bool Node::has_nodeid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Node::set_has_nodeid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Node::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Node::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nodeid();
}
inline const ::std::string& Node::nodeid() const {
  // @@protoc_insertion_point(field_get:modeTable.Node.nodeID)
  return nodeid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Node.nodeID)
}
inline void Node::set_nodeid(const char* value) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Node.nodeID)
}
inline void Node::set_nodeid(const char* value, size_t size) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Node.nodeID)
}
inline ::std::string* Node::mutable_nodeid() {
  set_has_nodeid();
  // @@protoc_insertion_point(field_mutable:modeTable.Node.nodeID)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_nodeid() {
  clear_has_nodeid();
  return nodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    set_has_nodeid();
  } else {
    clear_has_nodeid();
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Node.nodeID)
}

// -------------------------------------------------------------------

// Link

// required int32 transCode = 1;
inline bool Link::has_transcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Link::set_has_transcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Link::clear_has_transcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Link::clear_transcode() {
  transcode_ = 0;
  clear_has_transcode();
}
inline ::google::protobuf::int32 Link::transcode() const {
  // @@protoc_insertion_point(field_get:modeTable.Link.transCode)
  return transcode_;
}
inline void Link::set_transcode(::google::protobuf::int32 value) {
  set_has_transcode();
  transcode_ = value;
  // @@protoc_insertion_point(field_set:modeTable.Link.transCode)
}

// required string fromNodeID = 4;
inline bool Link::has_fromnodeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Link::set_has_fromnodeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Link::clear_has_fromnodeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Link::clear_fromnodeid() {
  fromnodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fromnodeid();
}
inline const ::std::string& Link::fromnodeid() const {
  // @@protoc_insertion_point(field_get:modeTable.Link.fromNodeID)
  return fromnodeid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_fromnodeid(const ::std::string& value) {
  set_has_fromnodeid();
  fromnodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Link.fromNodeID)
}
inline void Link::set_fromnodeid(const char* value) {
  set_has_fromnodeid();
  fromnodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Link.fromNodeID)
}
inline void Link::set_fromnodeid(const char* value, size_t size) {
  set_has_fromnodeid();
  fromnodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Link.fromNodeID)
}
inline ::std::string* Link::mutable_fromnodeid() {
  set_has_fromnodeid();
  // @@protoc_insertion_point(field_mutable:modeTable.Link.fromNodeID)
  return fromnodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Link::release_fromnodeid() {
  clear_has_fromnodeid();
  return fromnodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_allocated_fromnodeid(::std::string* fromnodeid) {
  if (fromnodeid != NULL) {
    set_has_fromnodeid();
  } else {
    clear_has_fromnodeid();
  }
  fromnodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fromnodeid);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Link.fromNodeID)
}

// required string toNodeID = 5;
inline bool Link::has_tonodeid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Link::set_has_tonodeid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Link::clear_has_tonodeid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Link::clear_tonodeid() {
  tonodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tonodeid();
}
inline const ::std::string& Link::tonodeid() const {
  // @@protoc_insertion_point(field_get:modeTable.Link.toNodeID)
  return tonodeid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_tonodeid(const ::std::string& value) {
  set_has_tonodeid();
  tonodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:modeTable.Link.toNodeID)
}
inline void Link::set_tonodeid(const char* value) {
  set_has_tonodeid();
  tonodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:modeTable.Link.toNodeID)
}
inline void Link::set_tonodeid(const char* value, size_t size) {
  set_has_tonodeid();
  tonodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:modeTable.Link.toNodeID)
}
inline ::std::string* Link::mutable_tonodeid() {
  set_has_tonodeid();
  // @@protoc_insertion_point(field_mutable:modeTable.Link.toNodeID)
  return tonodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Link::release_tonodeid() {
  clear_has_tonodeid();
  return tonodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_allocated_tonodeid(::std::string* tonodeid) {
  if (tonodeid != NULL) {
    set_has_tonodeid();
  } else {
    clear_has_tonodeid();
  }
  tonodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tonodeid);
  // @@protoc_insertion_point(field_set_allocated:modeTable.Link.toNodeID)
}

// -------------------------------------------------------------------

// MTFile

// repeated .modeTable.Node nodeList = 1;
inline int MTFile::nodelist_size() const {
  return nodelist_.size();
}
inline void MTFile::clear_nodelist() {
  nodelist_.Clear();
}
inline const ::modeTable::Node& MTFile::nodelist(int index) const {
  // @@protoc_insertion_point(field_get:modeTable.MTFile.nodeList)
  return nodelist_.Get(index);
}
inline ::modeTable::Node* MTFile::mutable_nodelist(int index) {
  // @@protoc_insertion_point(field_mutable:modeTable.MTFile.nodeList)
  return nodelist_.Mutable(index);
}
inline ::modeTable::Node* MTFile::add_nodelist() {
  // @@protoc_insertion_point(field_add:modeTable.MTFile.nodeList)
  return nodelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::modeTable::Node >&
MTFile::nodelist() const {
  // @@protoc_insertion_point(field_list:modeTable.MTFile.nodeList)
  return nodelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::modeTable::Node >*
MTFile::mutable_nodelist() {
  // @@protoc_insertion_point(field_mutable_list:modeTable.MTFile.nodeList)
  return &nodelist_;
}

// repeated .modeTable.Link LinkList = 2;
inline int MTFile::linklist_size() const {
  return linklist_.size();
}
inline void MTFile::clear_linklist() {
  linklist_.Clear();
}
inline const ::modeTable::Link& MTFile::linklist(int index) const {
  // @@protoc_insertion_point(field_get:modeTable.MTFile.LinkList)
  return linklist_.Get(index);
}
inline ::modeTable::Link* MTFile::mutable_linklist(int index) {
  // @@protoc_insertion_point(field_mutable:modeTable.MTFile.LinkList)
  return linklist_.Mutable(index);
}
inline ::modeTable::Link* MTFile::add_linklist() {
  // @@protoc_insertion_point(field_add:modeTable.MTFile.LinkList)
  return linklist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::modeTable::Link >&
MTFile::linklist() const {
  // @@protoc_insertion_point(field_list:modeTable.MTFile.LinkList)
  return linklist_;
}
inline ::google::protobuf::RepeatedPtrField< ::modeTable::Link >*
MTFile::mutable_linklist() {
  // @@protoc_insertion_point(field_mutable_list:modeTable.MTFile.LinkList)
  return &linklist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace modeTable

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modeTable_2eproto__INCLUDED
